<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Rust vs CS DateTime Parsing | Relentless Optimizer</title>
<meta name=keywords content><meta name=description content="I originally wrote the C# version of this code to write a performance tuning tutorial for DateTime parsing. I came back after learning some Rust to try to compare the performance of the two languages."><meta name=author content="Scott Louvau"><link rel=canonical href=https://relentlessoptimizer.com/code/2024/01/30/rust-vs-cs-datetime-parsing/><link href=/assets/css/stylesheet.min.0b2e0140b43ef19b2a750e921516ad4fa6709d5410537b71ea94d625d11a0ddd.css integrity="sha256-Cy4BQLQ+8ZsqdQ6SFRatT6ZwnVQQU3tx6pTWJdEaDd0=" rel="preload stylesheet" as=style><link rel=icon href=https://relentlessoptimizer.com/favicon.svg type=image/svg+xml><link rel=icon href=https://relentlessoptimizer.com/favicon-128x128.png sizes=128x128><link rel=icon href=https://relentlessoptimizer.com/favicon-32x32.png sizes=32x32><link rel=icon href=https://relentlessoptimizer.com/favicon.ico sizes=16x16><meta name=generator content="Hugo 0.122.0"><meta property="og:title" content="Rust vs CS DateTime Parsing"><meta property="og:description" content="I originally wrote the C# version of this code to write a performance tuning tutorial for DateTime parsing. I came back after learning some Rust to try to compare the performance of the two languages."><meta property="og:type" content="article"><meta property="og:url" content="https://relentlessoptimizer.com/code/2024/01/30/rust-vs-cs-datetime-parsing/"><meta property="article:section" content="code"><meta property="article:published_time" content="2024-01-30T00:00:00+00:00"><meta property="article:modified_time" content="2024-01-30T00:00:00+00:00"></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><div class=logo><a href=/ accesskey=h title="Relentless Optimizer (Alt + H)">Relentless Optimizer</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon"><use xlink:href="/assets/icons.svg#moon"/></svg><svg id="sun"><use xlink:href="/assets/icons.svg#sun"/></svg></button></span></div><nav class=site-nav><input type=checkbox id=nav-trigger class=nav-trigger>
<label for=nav-trigger><span class=menu-icon><svg><use xlink:href="/assets/icons.svg#menu"/></svg></span></label><div class=trigger><a class=page-link href=/about title=About>About</a>
<a class=page-link href=/code/ title=Code>Code</a>
<a class=page-link href=/finance/ title=Finance>Finance</a>
<a class=page-link href=/gaming/ title=Gaming>Gaming</a>
<a class=page-link href=/life/ title=Life>Life</a>
<a class=page-link href=/retire-early title="Retire Early">Retire Early</a></div></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=/>Home</a>&nbsp;»&nbsp;<a href=/code/>Code</a></div><h1 class=post-title>Rust vs CS DateTime Parsing</h1><div class=post-meta>January 30, 2024 · 10 min · Scott Louvau</div></header><div class=post-content><p>I originally wrote the C# version of this code to write a performance tuning <a href=/code/2022/08/10/performance-tuning-from-1.5m-to-50m-datetimes-parsed-per-second-in-c/>tutorial</a> for DateTime parsing. I came back after learning some Rust to try to compare the performance of the two languages.</p><p>The <a href=https://github.com/ScottLouvau/experiments/tree/main/datetime-parse>code</a> parses a text file with 10M DateTimes in &ldquo;2022-04-14T02:32:53.4028225Z&rdquo; format. I tried to use the most likely &ldquo;naive&rdquo; implementations to start, and then tuned the two implementations based on profiling results.</p><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>It&rsquo;s hard to give a simple answer about whether Rust or C# was faster in this comparison.</p><p>If you try a naive implementation, Rust&rsquo;s chrono::DateTime::parse_from_rfc3339 was 2x faster than C#&rsquo;s DateTime.ParseExact but 2x slower than C#&rsquo;s DateTimeOffset.ParseExact, so your experience depends on whether you know about the newer DateTimeOffset type. It&rsquo;s possible that there is a faster naive Rust implementation, but I don&rsquo;t have much experience with Rust yet, so I don&rsquo;t know of any.</p><p>Near the end of my optimizations, Rust pulled distinctly ahead. Reading the file in blocks of bytes, looking for newlines, and parsing in custom code took 210 ms in Rust versus 300 ms in C#. Avoiding looking for newlines by splitting at a known length took 115 ms in Rust vs. 200 ms in in C#. However, my not-safe-for-production, fully unrolled, no error checking version came out very similar, at 95 ms for each.</p><p>My conclusion was that I&rsquo;m likely to be able to get Rust to run distinctly faster in tuned, custom code. The built-in APIs I used in this example aren&rsquo;t as well tuned as C#&rsquo;s newer types, which eliminated a lot of the benefit.</p><h3 id=merged-results>Merged Results<a hidden class=anchor aria-hidden=true href=#merged-results>#</a></h3><p>M1 MacBook Pro, 16GB RAM, 512GB SSD, 8-core CPU, 14-core GPU
MacOS 14.2.1. Rust 1.74.0, .NET 8.0.0, .NET 7.0.14, .NET 6.0.25</p><table><thead><tr><th>Variation</th><th>Rust</th><th>NET 8</th><th>NET 7</th><th>NET 6</th></tr></thead><tbody><tr><td>DateTimeParse</td><td></td><td>3,314</td><td>3,445</td><td>4,117</td></tr><tr><td>DateTimeParseExact</td><td></td><td>2,087</td><td>2,768</td><td>3,462</td></tr><tr><td>Rust Naive</td><td>1,017</td><td>3,504</td><td>3,513</td><td>4,104</td></tr><tr><td>Rust Naive ReadLine</td><td>1,316</td><td></td><td></td><td></td></tr><tr><td>Rust String Iter, Custom Parse</td><td>427</td><td></td><td></td><td></td></tr><tr><td>Rust String, Custom Parse</td><td>401</td><td></td><td></td><td></td></tr><tr><td>DateTimeParseExactNotUtc</td><td></td><td>1,098</td><td>1,352</td><td>1,535</td></tr><tr><td>DateTimeOffsetParseExact</td><td></td><td>510</td><td>897</td><td>846</td></tr><tr><td>SpanOfChar</td><td></td><td>313</td><td>424</td><td>538</td></tr><tr><td>Rust All Bytes, Custom Parse</td><td>297</td><td></td><td></td><td></td></tr><tr><td>BytesAndCustomParse</td><td>206</td><td>300</td><td>328</td><td>500</td></tr><tr><td>KnownLengthSplitAndCustomParse</td><td></td><td>255</td><td>296</td><td>376</td></tr><tr><td>Custom_MyParse</td><td>115</td><td>200</td><td>490</td><td>462</td></tr><tr><td>Custom_NoErrors</td><td>95</td><td>95</td><td>100</td><td>116</td></tr></tbody></table><h2 id=usage>Usage<a hidden class=anchor aria-hidden=true href=#usage>#</a></h2><ul><li><p>Run C# version first to generate the sample data, datetime-parse/Sample.DatesOnly.log.</p></li><li><p>Use &lsquo;dotnet run -c Release -f net8.0&rsquo; (7.0 | 6.0) to run C# versions.</p></li><li><p>Use &lsquo;cargo run -r&rsquo; to run the Rust version.</p></li></ul><p>You can extend the runtime and iteration limit in the Time() methods in each codebase to get more accurate numbers, but I chose relatively short runtimes because I iterated on the code many times and didn&rsquo;t want to wait minutes to see the results.</p><p>My C# and Rust versions both output Markdown-style tables with the results. I&rsquo;ve given variations that are reasonably equivalent the same name in both languages. Others are logical steps from naive to optimized but not really directly comparable.</p><h2 id=details>Details<a hidden class=anchor aria-hidden=true href=#details>#</a></h2><p>In normal performance tuning, I start with a correct, well known way to do something. I profile it to find the aspects of the work that are slowest, and experiment with alternative built-in implementation options to see what&rsquo;s fastest. After I&rsquo;ve exhausted the available options, I look at custom implementations to avoid doing any work that doesn&rsquo;t absolutely have to be done to solve the problem. At the end, I&rsquo;ll often cut things that ARE required to understand the potential gains if I can figure out how to loosen the problem requirements.</p><p>In this comparison, I started out doing my normal tuning approach with both C# and Rust, but the optimization work leads in different directions - the straightforward implementations have different bottlenecks. I&rsquo;ve tried to add some apples-to-apples implementation options here to get more direct comparisons between the languages.</p><h3 id=c>C#<a hidden class=anchor aria-hidden=true href=#c>#</a></h3><p>In C#, the most well known method you could use is DateTime.Parse, but it&rsquo;s not fair to compare because it has to detect the format of each string and it has to convert the DateTime to local time. I&rsquo;ve included it to show how much faster the next-best C# option is.</p><p>Since I&rsquo;m working with a fixed format and I want the original UTC value, the reasonable starting point is DateTime.ParseExact. I was surprised that most of the runtime is time zone adjustment, even though the arguments I pass tell the function that the text to parse and the output I want will both be UTC. You can see this when I ask for a local DateTime instead and the speed doubles.</p><p>In trying variations, I then looked at the newer DateTimeOffset.ParseExact, and found it was 4x faster (<strong>~500ms</strong>) - clearly, it isn&rsquo;t doing any time zone work. It&rsquo;s very impressive that C# can convert the file to UTF-16, create a string instance per line, and do the parsing at this speed overall.</p><p>I measured just File.ReadLines (~250 ms) and File.ReadAllBytes (~50 ms). This shows me that File.ReadLines is fast enough for DateTime.ParseExact, but DateTimeOffset could be faster without creating a string per line (and even more so without converting to UTF-16).</p><p>My next implementation, Span, reads the file in blocks but maintains the UTF-16 conversion. I use Spans to avoid a string per line, and fortunately there&rsquo;s a DateTimeOffset.ParseExact overload for that. It runs in <strong>310 ms</strong>.</p><p>Next, let&rsquo;s try reading as bytes. I didn&rsquo;t see a DateTime parsing option for Span<byte>, so at this point I have to parse the numbers in the DateTime separately and construct it. Utf8Parser does provide a built-in parse. This gets down to <strong>300 ms</strong>, which is a smaller gain than I would&rsquo;ve expected. It shows that the .NET UTF-8 to UTF-16 conversion is very fast.</p><p>Next, let&rsquo;s split at known length rather than newlines. This should get the I/O part to be as fast as my ReadAllBytes experiment. Taking out the newline searches gets the runtime to <strong>250 ms</strong>.</p><p>I then tried my own number parsing function. It&rsquo;s likely different from the Utf8Parser one because it tracks whether digits are out of range but doesn&rsquo;t stop the loop early if so, avoiding a conditional branch in the inner loop. Interestingly, this version is slower than the previous one in .NET 6.0 and 7.0, but faster in .NET 8.0 at <strong>~200 ms</strong>.</p><p>Finally, my last variant eliminates error handling, unrolls the digit loops to parse exactly a known number of digits for each part, and inlines the parsing function overall. I see <strong>95 ms</strong> for this version. I don&rsquo;t think this is safe for real use, but it demonstrates how much of our current runtime is spent on safety and a generic digit parsing loop.</p><p>C# has also gotten quite a bit faster between .NET 6.0 and 8.0. The DateTimeOffset version, for example, went from ~850 to ~510 ms. My second-to-last implementation was 460 ms in .NET 6.0 and is 200 ms in .NET 8.0. It&rsquo;s a huge improvement.</p><h3 id=rust>Rust<a hidden class=anchor aria-hidden=true href=#rust>#</a></h3><p>In Rust, my naive version took about <strong>1,000 ms</strong> to get through the 10 M DateTimes. That&rsquo;s about twice as fast as DateTime.ParseExact and half as fast as DateTimeOffset.ParseExact.</p><p>My first concern, though, is that Rust is reading the whole file at once, which I wouldn&rsquo;t want to do for a huge file. I tried using BufReader::lines to read by line, but it&rsquo;s 30% slower than the original. I&rsquo;ll have to figure out my own way to read the file in smaller parts.</p><p>I measured the DateTime parsing alone by parsing a constant 10M times, and it took <strong>750 ms</strong>. That means replacing the default parsing is the next step.</p><p>I next created my own parsing function, using str.parse<type>. This version is down to <strong>410 ms</strong>, a drastic improvement. I tried to create an iterator version to factor the code, but it&rsquo;s slower at 450 ms despite being the same code on both sides of the factoring boundary.</p><p>Next, I switch to reading as bytes and using a custom number parsing function, as I did in C#. This version runs in <strong>300 ms</strong>, another significant improvement.</p><p>I still need to switch from reading the whole file to reading in blocks, and now that I&rsquo;m working in bytes that&rsquo;s easier. Swapping to blocks brings the runtime down to <strong>210 ms</strong>.</p><p>Next I split at known boundaries rather than looking for newlines (something the last three C# versions also did) and find that this version is drastically faster at <strong>115 ms</strong>. This is the last version I would reasonably use. It&rsquo;s nearly identical in terms of code and work done to the second-to-last C# implementation - read bytes in blocks, split at known lengths, parse with a custom function.</p><p>Finally, I write one comparable to the last C# implementation, with fully unrolled loops and no error checking. This version is <strong>95 ms</strong>.</p><p>Major Performance Components:</p><ul><li>UTF-8 to UTF-16 conversion (C# only)</li><li>UTF-8 validation</li><li>Finding newlines</li><li>Creating a string (or slice) per line</li><li>Allocating per line</li><li>Identifying DateTime format or parsing format string</li><li>Time Zone Correction</li></ul><h2 id=todo>TODO<a hidden class=anchor aria-hidden=true href=#todo>#</a></h2><ul><li>Analyze assembly for the fastest versions to look for key differences.</li></ul><h2 id=current-results>Current Results<a hidden class=anchor aria-hidden=true href=#current-results>#</a></h2><h3 id=2021-m1-macbook-pro>2021 M1 MacBook Pro<a hidden class=anchor aria-hidden=true href=#2021-m1-macbook-pro>#</a></h3><p>8-core CPU, 14-core GPU, 16GB RAM, 512GB SSD
MacOS 14.2.1</p><table><thead><tr><th>ms</th><th>Rust 1.74.0</th><th>SumMillis</th></tr></thead><tbody><tr><td>1017</td><td>Naive Rust</td><td>4995071171</td></tr><tr><td>1316</td><td>Naive Rust ReadLine</td><td>4995071171</td></tr><tr><td>427</td><td>Rust String Iter, Custom Parse</td><td>4995071171</td></tr><tr><td>401</td><td>Rust String, Custom Parse</td><td>4995071171</td></tr><tr><td>297</td><td>Rust All Bytes, Custom Parse</td><td>4995071171</td></tr><tr><td>206</td><td>BytesAndCustomParse</td><td>4995071171</td></tr><tr><td>115</td><td>Custom_MyParse</td><td>4995071171</td></tr><tr><td>95</td><td>Custom_NoErrors</td><td>4995071171</td></tr></tbody></table><table><thead><tr><th>ms</th><th>.NET 8.0.0</th><th>SumMillis</th></tr></thead><tbody><tr><td>3,314</td><td>DateTimeParse</td><td>4995071171</td></tr><tr><td>2,087</td><td>DateTimeParseExact</td><td>4995071171</td></tr><tr><td>3,504</td><td>RustNaiveClosest</td><td>4995071171</td></tr><tr><td>1,098</td><td>DateTimeParseExactNotUtc</td><td>4995071171</td></tr><tr><td>510</td><td>DateTimeOffsetParseExact</td><td>4995071171</td></tr><tr><td>313</td><td>SpanOfChar</td><td>4995071171</td></tr><tr><td>300</td><td>BytesAndCustomParse</td><td>4995071171</td></tr><tr><td>255</td><td>KnownLengthSplitAndCustomParse</td><td>4995071171</td></tr><tr><td>200</td><td>Custom_MyParse</td><td>4995071171</td></tr><tr><td>95</td><td>Custom_NoErrors</td><td>4995071171</td></tr></tbody></table><table><thead><tr><th>ms</th><th>.NET 7.0.14</th><th>SumMillis</th></tr></thead><tbody><tr><td>3,445</td><td>DateTimeParse</td><td>4995071171</td></tr><tr><td>2,768</td><td>DateTimeParseExact</td><td>4995071171</td></tr><tr><td>3,513</td><td>RustNaiveClosest</td><td>4995071171</td></tr><tr><td>1,352</td><td>DateTimeParseExactNotUtc</td><td>4995071171</td></tr><tr><td>897</td><td>DateTimeOffsetParseExact</td><td>4995071171</td></tr><tr><td>424</td><td>SpanOfChar</td><td>4995071171</td></tr><tr><td>328</td><td>BytesAndCustomParse</td><td>4995071171</td></tr><tr><td>296</td><td>KnownLengthSplitAndCustomParse</td><td>4995071171</td></tr><tr><td>490</td><td>Custom_MyParse</td><td>4995071171</td></tr><tr><td>100</td><td>Custom_NoErrors</td><td>4995071171</td></tr></tbody></table><table><thead><tr><th>ms</th><th>.NET 6.0.25</th><th>SumMillis</th></tr></thead><tbody><tr><td>4,117</td><td>DateTimeParse</td><td>4995071171</td></tr><tr><td>3,462</td><td>DateTimeParseExact</td><td>4995071171</td></tr><tr><td>4,104</td><td>RustNaiveClosest</td><td>4995071171</td></tr><tr><td>1,535</td><td>DateTimeParseExactNotUtc</td><td>4995071171</td></tr><tr><td>846</td><td>DateTimeOffsetParseExact</td><td>4995071171</td></tr><tr><td>538</td><td>SpanOfChar</td><td>4995071171</td></tr><tr><td>500</td><td>BytesAndCustomParse</td><td>4995071171</td></tr><tr><td>376</td><td>KnownLengthSplitAndCustomParse</td><td>4995071171</td></tr><tr><td>462</td><td>Custom_MyParse</td><td>4995071171</td></tr><tr><td>116</td><td>Custom_NoErrors</td><td>4995071171</td></tr></tbody></table><p>On M1 MacBook Pro, within Docker, on rust:latest image.</p><table><thead><tr><th>ms</th><th>Rust</th><th>SumMillis</th></tr></thead><tbody><tr><td>1150</td><td>Rust Naive</td><td>4995071171</td></tr><tr><td>1307</td><td>Rust Naive ReadLine</td><td>4995071171</td></tr><tr><td>412</td><td>Rust String Iter, Custom Parse</td><td>4995071171</td></tr><tr><td>397</td><td>Rust String, Custom Parse</td><td>4995071171</td></tr><tr><td>296</td><td>Rust All Bytes, Custom Parse</td><td>4995071171</td></tr><tr><td>180</td><td>BytesAndCustomParse</td><td>4995071171</td></tr><tr><td>91</td><td>Custom_MyParse</td><td>4995071171</td></tr><tr><td>78</td><td>Custom_NoErrors</td><td>4995071171</td></tr></tbody></table><h3 id=2020-lenovo-ideapad-flex-5-14are05>2020 Lenovo IdeaPad Flex 5 (14ARE05)<a hidden class=anchor aria-hidden=true href=#2020-lenovo-ideapad-flex-5-14are05>#</a></h3><p>Ryzen 4700U (8 core, 8 thread, 4.1 GHz), 16 GB DDR4-3200, 512 GB NVMe SSD
Ubuntu 22.04.3 LTS</p><table><thead><tr><th>Rust 1.75.0</th><th>ms</th><th>SumMillis</th></tr></thead><tbody><tr><td>Rust Naive</td><td>1665</td><td>4996109444</td></tr><tr><td>Rust Naive ReadLine</td><td>1870</td><td>4996109444</td></tr><tr><td>Rust String Iter, Custom Parse</td><td>683</td><td>4996109444</td></tr><tr><td>Rust String, Custom Parse</td><td>638</td><td>4996109444</td></tr><tr><td>Rust All Bytes, Custom Parse</td><td>504</td><td>4996109444</td></tr><tr><td>BytesAndCustomParse</td><td>302</td><td>4996109444</td></tr><tr><td>Custom_MyParse</td><td>196</td><td>4996109444</td></tr><tr><td>Custom_NoErrors</td><td>140</td><td>4996109444</td></tr></tbody></table><table><thead><tr><th>.NET 8.0.1</th><th>ms</th><th>SumMillis</th></tr></thead><tbody><tr><td>DateTimeParse</td><td>2,973</td><td>4996109444</td></tr><tr><td>DateTimeParseExact</td><td>3,343</td><td>4996109444</td></tr><tr><td>RustNaiveClosest</td><td>4,182</td><td>4996109444</td></tr><tr><td>DateTimeParseExactNotUtc</td><td>949</td><td>4996109444</td></tr><tr><td>DateTimeOffsetParseExact</td><td>725</td><td>4996109444</td></tr><tr><td>SpanOfChar</td><td>412</td><td>4996109444</td></tr><tr><td>BytesAndCustomParse</td><td>396</td><td>4996109444</td></tr><tr><td>KnownLengthSplitAndCustomParse</td><td>333</td><td>4996109444</td></tr><tr><td>Custom_MyParse</td><td>289</td><td>4996109444</td></tr><tr><td>Custom_NoErrors</td><td>111</td><td>4996109444</td></tr></tbody></table><table><thead><tr><th>.NET 7.0.15</th><th>ms</th><th>SumMillis</th></tr></thead><tbody><tr><td>DateTimeParse</td><td>3,388</td><td>4996109444</td></tr><tr><td>DateTimeParseExact</td><td>4,767</td><td>4996109444</td></tr><tr><td>RustNaiveClosest</td><td>6,087</td><td>4996109444</td></tr><tr><td>DateTimeParseExactNotUtc</td><td>1,250</td><td>4996109444</td></tr><tr><td>DateTimeOffsetParseExact</td><td>1,370</td><td>4996109444</td></tr><tr><td>SpanOfChar</td><td>639</td><td>4996109444</td></tr><tr><td>BytesAndCustomParse</td><td>451</td><td>4996109444</td></tr><tr><td>KnownLengthSplitAndCustomParse</td><td>382</td><td>4996109444</td></tr><tr><td>Custom_MyParse</td><td>420</td><td>4996109444</td></tr><tr><td>Custom_NoErrors</td><td>173</td><td>4996109444</td></tr></tbody></table><table><thead><tr><th>.NET 6.0.26</th><th>ms</th><th>SumMillis</th></tr></thead><tbody><tr><td>DateTimeParse</td><td>3,903</td><td>4996109444</td></tr><tr><td>DateTimeParseExact</td><td>5,522</td><td>4996109444</td></tr><tr><td>RustNaiveClosest</td><td>6,805</td><td>4996109444</td></tr><tr><td>DateTimeParseExactNotUtc</td><td>1,350</td><td>4996109444</td></tr><tr><td>DateTimeOffsetParseExact</td><td>1,360</td><td>4996109444</td></tr><tr><td>SpanOfChar</td><td>895</td><td>4996109444</td></tr><tr><td>BytesAndCustomParse</td><td>528</td><td>4996109444</td></tr><tr><td>KnownLengthSplitAndCustomParse</td><td>414</td><td>4996109444</td></tr><tr><td>Custom_MyParse</td><td>382</td><td>4996109444</td></tr><tr><td>Custom_NoErrors</td><td>153</td><td>4996109444</td></tr></tbody></table><h2 id=issues>Issues<a hidden class=anchor aria-hidden=true href=#issues>#</a></h2><p>In Rust, the most commonly shown way to read a file by line is creating a separate string per line.
I think people tuning performance wouldn&rsquo;t do this - they would read blocks and pass string slices around.
However, I don&rsquo;t know of an easy built-in way to do that. Maybe I&rsquo;m just not looking in the right places for docs.</p></div><footer class=post-footer><nav class=paginav><a class=prev href=/gaming/2023/06/08/my-best-wordle-guesses/><span class=title>« Previous Post</span><br><span>My Best Wordle Guesses</span>
</a><a class=next href=/gaming/2024/02/06/on-optimizing-qwertle/><span class=title>Next Post »</span><br><span>On Optimizing QWERTLE</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=/>Relentless Optimizer</a>, all code <a href=/LICENSE.txt>MIT License</a></span>
<span>&#183;</span>
<span>Incessantly optimizing code, games, and finances.</span><div class=social-icons><a class=social-rss href=index.xml target=_blank title=Rss><svg><use xlink:href="/assets/icons.svg#rss"/></svg>
</a><a class=social-email href=obfuscated target=_blank title=Email><svg><use xlink:href="/assets/icons.svg#email"/></svg>
</a><a class=social-github href=https://github.com/ScottLouvau target=_blank title=Github><svg><use xlink:href="/assets/icons.svg#github"/></svg>
</a><a class=social-linkedin href=https://linkedin.com/in/scott-louvau-97846531 target=_blank title="Linked in"><svg><use xlink:href="/assets/icons.svg#linkedin"/></svg></a></div></footer><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>var mail=["mail","to:","scottlo","@","out","look","."];document.querySelectorAll(".social-email").forEach(e=>e.href=mail.join("")+"com")</script></body></html>